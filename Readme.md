# Репозиторий с решениями задач на C# для курса Алгоритмизация и программирование

Большая часть инфраструктурного кода сгенерировано с помощью LLM и автор сам не понимает, что происходит, но в данном случае это не имеет абсолютно никакого значения.

## Обзор архитектуры проекта

Проект построен по принципу "плагинов", где каждое решение является "плагином" для главной программы-запускателя (`Runner`).

1.  **`Runner` (Запускатель)**: Это единственное исполняемое приложение в проекте. При запуске он не знает о конкретных задачах. Вместо этого он использует **рефлексию** для сканирования всех подключенных проектов-библиотек (`.dll` файлов) и ищет в них классы, которые реализуют общий интерфейс `ISolution`. Найденные классы он отображает в виде меню, позволяя запустить любое решение.

2.  **`Tasks.Common` (Общий проект)**: Содержит базовый "контракт" — интерфейс `ISolution`. Любой класс, который хочет быть запущенным `Runner`'ом, должен реализовывать этот интерфейс.

3.  **`Tasks.*` (Проекты с задачами)**: Каждый проект, например `Tasks.MathCalculations`, является библиотекой классов и содержит одну или несколько реализаций решения конкретной задачи.

4.  **`Tasks.Tests` (Проект с тестами)**: Содержит автоматические юнит-тесты. Благодаря параметризованным тестам, один и тот же набор проверок может автоматически применяться ко всем альтернативным решениям одной и той же задачи.

## Как запустить проект

Для запуска основного приложения-меню (`Runner`), которое позволяет выбрать и выполнить любую из добавленных задач, выполните следующую команду из **корневой папки** проекта:

`dotnet run --project src/Runner/Runner.csproj` 
После запуска в консоли появится меню со списком всех найденных решений, сгруппированных по задачам. 
Вы можете выбрать номер решения и нажать Enter для его выполнения.

Принцип работы `Runner`'а (поиск решений с помощью рефлексии) подробно описан в разделе "Обзор архитектуры проекта".

---

## Как работать с проектом

### 1. Как добавить новое РЕШЕНИЕ к существующей ЗАДАЧЕ

Допустим, вы хотите добавить `MathCalculationsAlternative` к задаче `MathCalculations`.

1.  **Создайте новый класс**: В проекте `src/Tasks/MathCalculations` создайте новый файл `MathCalculationsAlternative.cs`.

2.  **Реализуйте интерфейс**: Класс должен реализовывать тот же интерфейс, что и основное решение (например, `IMathCalculationSolution`). Это обеспечит наличие методов `Run()` и `Calculate()`.

3.  **Добавьте в тесты**: Откройте тестовый файл `tests/Tasks.Tests/MathCalculationsTests.cs`. Найдите метод `GetSolutions()` и добавьте в него экземпляр вашего нового класса:
        ```csharp
        public static IEnumerable<object[]> GetSolutions()
        {
            yield return new object[] { new MathCalculations() };
            // Добавляем новую строку
            yield return new object[] { new MathCalculationsAlternative() };
        }
        ```

4.  **Готово!** `Runner` автоматически найдет ваше новое решение. А при запуске `dotnet test` все существующие тесты будут выполнены и для вашей новой реализации.

### 2. Как добавить новую ЗАДАЧУ

**Рекомендуемый способ: используйте скрипт `makeTask.sh`**

Просто запустите `./makeTask.sh --name НазваниеЗадачи` из корневой директории проекта, и скрипт автоматически создаст всю необходимую структуру файлов и обновит проект.

Например:
```
./makeTask.sh --name StringReversal
```

<details>
<summary>Как работает скрипт под капотом</summary>

Скрипт автоматически:
1. Создает директорию `src/Tasks/НазваниеЗадачи`
2. Генерирует файлы: интерфейс `IНазваниеЗадачиSolution.cs`, класс `НазваниеЗадачи.cs`, проектный файл `Tasks.НазваниеЗадачи.csproj`
3. Создает файл тестов `tests/Tasks.Tests/НазваниеЗадачиTests.cs`
4. Добавляет ссылки в `Tasks.Tests.csproj`
5. Обновляет файл решения `Tasks.sln` с новыми проектами и их конфигурациями

</details>

**Ручной способ (без скрипта)**

<details>
<summary>инструкции по ручному добавлению задачи</summary>

Допустим, вы хотите добавить задачу `StringReversal`.

1.  **Создайте проект**: В терминале, из корневой папки, выполните:
    `dotnet new classlib -n Tasks.StringReversal -o src/Tasks/StringReversal2`

2. **Добавьте в решение и настройте ссылки**:
    `dotnet sln add src/Tasks/StringReversal/Tasks.StringReversal.csproj`

3. **Runner должен "видеть" новый проект**:
    `dotnet add src/Runner/Runner.csproj reference src/Tasks/StringReversal/Tasks.StringReversal.csproj`

4. **Новый проект должен "видеть" Tasks.Common**
    `dotnet add src/Tasks/StringReversal/Tasks.StringReversal.csproj reference src/Tasks.Common/Tasks.Common.csproj`

5. **Создайте интерфейсы и классы**:
    Внутри `src/Tasks/StringReversal` создайте:
    *   Интерфейс `IStringReversalSolution : ISolution` с методом `string Reverse(string input)`.
    *   Класс `IterativeSolution : IStringReversalSolution`, реализующий этот интерфейс.

</details>

### 3. Как добавить ТЕСТЫ для новой ЗАДАЧИ

**При использовании скрипта `makeTask.sh` файл тестов создается автоматически.**

<details>
<summary>Инструкции по ручному добавлению тестов</summary>

1.  **Добавьте ссылку**: Свяжите тестовый проект с вашим новым проектом задачи.
    dotnet add tests/Tasks.Tests/Tasks.Tests.csproj reference src/Tasks/StringReversal/Tasks.StringReversal.csproj
2.  **Создайте тестовый файл**: В `tests/Tasks.Tests` создайте файл `StringReversalTests.cs`.
3.  **Напишите параметризованный тест**: Используйте `[Theory]` и `[MemberData]` по аналогии с `MathCalculationsTests.cs`, чтобы ваши тесты могли работать со всеми будущими решениями этой задачи.

</details>

---

## ❗ Важно: Подготовка решения для сдачи в систему автопроверки

Система автоматической проверки не использует наш `Runner`. 
Она ожидает **один файл `Program.cs`** с классической структурой, который читает данные из стандартного ввода и пишет результат в стандартный вывод.

**Наша архитектура с `Run()` предназначена для удобной локальной разработки, а для сдачи нужно подготовить "чистый" файл.**

### Алгоритм подготовки файла к сдаче:

1.  Выберите, какое из ваших решений вы хотите сдать (например, `MathCalculations`).
2.  Создайте временный файл `Program.cs` или просто скопируйте шаблон ниже.
3.  Возьмите **чистую логику** из вашего метода `Calculate()` и вставьте ее внутрь метода `Main`.
4.  Убедитесь, что вы соблюдаете все правила системы.

### Пример готового файла `Program.cs` для сдачи задачи `MathCalculations`
```csharp
// Правило 1: Убедитесь, что using System на месте
using System;

class Program
{
    // Правило 2: Вся логика должна быть в статическом методе Main
    static void Main(string[] args)
    {
        // Правило 3: УДАЛИТЬ все приглашения к вводу, типа Console.Write("Введите а:")
        // Система подает данные на вход автоматически.
        string input = Console.ReadLine();
        double a = double.Parse(input);

        // Это чистая логика, скопированная из вашего метода Calculate()
        double expression = (2 * a + Math.Sin(Math.Abs(3 * a))) / 3.56;

        if (expression < 0)
        {
            // Если система ожидает какой-то вывод в случае ошибки, укажите его здесь.
            // Если нет - можно оставить пустым или вывести 0.
        }
        else
        {
            double x = Math.Sqrt(expression);
            // Правило 5: Округляем до того количества знаков, которое указано в задании
            double roundedX = Math.Round(x, 3);
            Console.WriteLine(roundedX);
        }
    }
}
```

### Чек-лист перед отправкой файла на проверку:

-   [ ] Код находится в структуре `namespace -> class Program -> static void Main`. Операторы верхнего уровня **не используются**.
-   [ ] Все строки с выводом в консоль, являющиеся подсказками для пользователя (`Console.Write`, `Console.WriteLine("Введите...")`), **полностью удалены или закомментированы**.
-   [ ] Программа читает данные через `Console.ReadLine()` и выводит результат через `Console.WriteLine()`.
-   [ ] Результат округлен **в точности** до того количества знаков, которое требуется в задании.
-   [ ] Вверху файла присутствует строка `using System;`.
-   [ ] Вы загружаете на проверку именно **файл `Program.cs`**, а не копируете код в редактор на сайте.
-   [ ] Код был предварительно отлажен локально в Visual Studio (или другой IDE) и работает корректно.